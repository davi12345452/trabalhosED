- Lógica do programa é encontrar o menor caminho entre pontos que o usuário quer visitar. Ele recebe os caminhos (preciso compreender melhor), os locais, definidos com seu valor em escala, e a visita do usuário. A saída deve ser o menor caminho em distância e os locais a percorrer. O primeiro local é o primeiro do arquivo de locais a visitar; o segundo é um outro local desse arquivo, aquele que tem o caminho mais curto a partir do primeiro; o terceiro é um outro local desse arquivo, aquele que tem o caminho mais curto a partir do segundo etc.
- Observações: nos arquivos são .csv e organizados por linha. Quando uma linha começar com # essa deve ser ignorada, além de quando estiverem em branco.
- Locais.csv: é composto por 3 ou 4 valores, separados por vírgula. Um código str (3 a 4 caracteres), latitude (double significando graus), longitude (double significando graus) e, opcional, uma descrição (string). Ou seja, é obrigatório ter código, latitude e longitude.
    
    ```txt
    # arquivo de locais para o t4
    reit, -29.72074, -53.7149, Reitoria da UFSM
    r001,-29.720762943264475, -53.71503046365687
    r002,-29.72052180159092, -53.715022344706945
    
    cpd,-29.720834276050986, -53.71365166959692, CPD
    cpd1,-29.720344057355437, -53.71376036465768
    memo,-29.719539789440816, -53.71506008766732, Memorial José Mariano da Rocha Filho
    mem1,-29.71957578928367, -53.715278784825564
    mem2,-29.719329996950908, -53.715334531157836
    ```
    
- Caminhos.csv: essa arquivo sempre vai conter 2 valores por linha válida. Esses valores são códigos, iguais ao do arquivo locais, significando vértices. A partir desses vértices, que serão a maneira lógica de como acessar tais pontos, calcula-se o caminho, usando latitude e longitude, definidos em locais.
    
    ```txt
    # arquivo de caminhos para o t4
    reit, r001
    r001,r002
    r002,cpd1
    r002,mem1
    mem1,mem2
    memo,mem1
    cpd,cpd1
    mem2,cam1
    ```
    
- Saide.csv: atenção, a saída é muito importante. Ela deve ser em formato [map]bbcode, contendo as latitudes e longitudes de cada local a passar ao longo do trajeto. Cada local que passar deve conter a latitude e longitude e deve ser separado por ; além de estar dentro de [map][/map]. Quando um dos locais que passou conter uma descrição, deve-se colocar ela, por exemplo:
    
    ```[map]bbcode
    [map]
    -29.72074,-53.7149(Reitoria da UFSM);
    -29.72074,-53.7149 -29.72076,-53.71503 -29.72058,-53.71504 -29.7204,-53.71373 -29.72083,-53.71365;
    -29.72083,-53.71365(CPD)
    [/map]
    ```
    
- O programa dever ser implementado em C, utilizando mais arquivos se necessário. Porém, cada arquivo .h, só poderá ser chamado em seu respectivo .c, não pode ser utilizados em outros TADs. Cada .c só pode possuir funções relativas ao seu .h. Além disso, deve ser implementado utilizando grafo.h:
    
    ```c
    #ifndef GRAFO_H
    #define GRAFO_H
    
    #include <stdbool.h>
    
    typedef struct _grafo *Grafo;
    
    // aloca e inicializa um grafo com n vértices
    // o grafo pode ser orientado ou não (afeta o processamento das arestas)
    // retorna um ponteiro para o grafo alocado
    Grafo g_cria(int n, bool orientado);
    
    // libera a memória usada pelo grafo
    void g_destroi(Grafo self);
    
    // retorna o número de vértices do grafo
    int g_nvertices(Grafo self);
    
    // insere uma aresta no grafo (ou altera o peso de uma aresta já existente)
    void g_ins_aresta(Grafo self, int origem, int destino, float peso);
    
    // remove uma aresta do grafo
    void g_rem_aresta(Grafo self, int origem, int destino);
    
    // inicia uma consulta a arestas do grafo.
    // as próximas chamadas a g_proxima_aresta devem retornar cada aresta do grafo
    void g_arestas(Grafo self);
    
    // inicia uma consulta a arestas do grafo.
    // as próximas chamadas à g_proxima_aresta devem retornar cada aresta do grafo que parte do vértice origem
    void g_arestas_que_partem(Grafo self, int origem);
    
    // retorna os dados sobre a próxima aresta de uma consulta
    // retorna true se ok ou false se não tem mais arestas ou se não foi iniciada uma consulta
    // cada ponteiro pode ser NULL, para o caso de não se estar interessado na informação associada
    // não se deve inserir ou remover arestas no grafo com uma consulta em andamento
    bool g_proxima_aresta(Grafo self, int *origem, int *destino, float *peso);
    
    #endif // GRAFO_H
    ```
    
- Dicas:
    
    Não necessitamos de uma precisão muito grande. Podemos aproximar o cálculo supondo que o planeta é uma esfera, e que o câmpus é um espaço 2d. Só queremos calcular a distância entre duas coordenadas. Dá para dividir em uma distância norte-sul (diferença entre latitudes) e uma distância leste-oeste (diferença entre longitudes), e depois considerar que essas distâncias são catetos de um triângulo retângulo cuja hipotenusa é o valor da distância que queremos.
    
    90 graus de diferença de latitude correspondem a um quarto da circunferência da terra ou 10000km.
    
    90 graus de diferença de longitude correspondem a um quarto da circunferência de um círculo que corta a terra horizontalmente na latitude considerada. Um quarto da circunferência desse círculo é cos(latitude)*10000km.

- Implementação:
Cria estruturas de dados para representar os Locais (com campos como código, latitude, longitude, e descrição) e os Caminhos (com dois códigos representando os vértices).

Escrever funções para ler os arquivos Locais.csv e Caminhos.csv. Certificar-se de ignorar as linhas que começam com # ou que estão em branco. Popular as estruturas de dados criadas no passo 1.

Criar uma função para calcular a distância entre dois locais dados suas latitudes e longitudes, de acordo com a dica fornecida.

Utilizar a estrutura de grafo fornecida para representar a relação entre os locais e os caminhos. Inicializar o grafo com a quantidade de locais e popular as arestas com as distâncias calculadas utilizando a função criada no passo 3.

Implementar o algoritmo Dijkstra para encontrar o menor caminho entre os pontos que o usuário deseja visitar. Irei precisar iterar sobre os locais que o usuário quer visitar e usar o algoritmo para encontrar o caminho mais curto entre eles.

Criar uma função para gerar a saída no formato desejado, com as coordenadas dos locais visitados e as descrições quando disponíveis.v